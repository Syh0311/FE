## [网络协议【4层、7层】](https://juejin.cn/post/6844903510509633550)



![计算机网络体系结构分层](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/11/690219fae5b0587fa26e2dee545e6200~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 基础是

1. 网络协议
2. 状态码
3. 报文结构
4. 简单的缓存策略

## 常见状态码

### 1xx

1xx 类状态码属于**提示信息**，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

1. 101 Switch Protocol
   - 升级协议，如从 http 到 ws，此时需要反向代理支持

### 2xx

2xx 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

1. 「**200 OK**」
   - 最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。
2. 「**204 No Content**」
   - 常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
3. 「**206 `Partial Content`**」
   - 是应⽤于 HTTP `分块下载或断点续传`，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。

### 3xx

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是**重定向**。

1. 「**301 Moved Permanently**」
   - 表示`永久重定向`，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
2. 「**302 Found**」
   - 表示`临时重定向`，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。
   - **301 和 302** 都会在`响应头⾥使⽤字段 Location`，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。 
   - 重定向时`改变 method: 把 POST 改成 GET`，于是有了 307
3. 「**304 Not Modified**」
   - 不跳转，表示资源未修改；可理解为缓存重定向，⽤于缓存控制。
4. 「**307 Temporary Redirect**」
   - 临时重定向，在`重定向时不会改变 method`

### 4xx

4xx 类状态码表示客户端发送的**报⽂有误**，服务器⽆法处理，也就是错误码的含义。

1. 「**400 Bad Request**」
   - 表示客户端请求的报⽂有错误，但只是个笼统的错误。
2. 「**403 Forbidden**」
   - 表示服务器禁⽌访问资源，并不是客户端的请求出错。
3. 「**404 Not Found**」
   - 表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

### 5xx

5xx 类状态码表示客户端请求报⽂正确，但是**服务器处理时内部发⽣了错误**，属于服务器端的错误码。

1. 「**500 Internal Server Error**」
   - 与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。
2. 「**501 Not Implemented**」
   - 表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。
3. 「**502 Bad Gateway**」
   - 通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。
4. 「**503 Service Unavailable**」
   - 表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后试”的意思。

#### 502 504区别

这两种异常状态码都与网关 Gateway 有关，首先明确两个概念

- Proxy (Gateway)，反向代理层或者网关层。在公司级应用中一般使用 Nginx 扮演这个角色
- Application (upstream serrver)，应用层服务【后端】，作为 Proxy 层的上游服务。在公司中一般为各种语言编写的服务器应用，如 Go/Java/Python/PHP/Node 等

此时关于 502 与 504 的区别就很显而易见

- `502 Bad Gateway`。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应
- `504 Gateway Timeout`。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间

## 缓存策略

### 相关文章

https://juejin.cn/post/7052527032491573279

http://www.alloyteam.com/2016/03/discussion-on-web-caching/

### 强缓存

- Expires  绝对时间，与客户端事件作对比
- Cache-Control  【优先级高】

#### Cache-Control字段 服务端参数

1. max-age

   - 多少秒内有效，相对时间  `数值为0相当于no-cache`

2. s-maxage 

   - 【优先级高于max-age】  `客户端 -> 代理服务器 -> 源服务器`

   - s-maxage用于代理缓存，max-age用于普通缓存；代理缓存优于普通缓存，因为不需要再去源站就能拿到数据

3. public  

   - 【可以被代理服务器缓存，可以被多个客户端缓存，`默认为private`】

4. private

   - 私有的，即只能被单独用户缓存，

5. no-cache

   - no-cache即**`协商缓存`**
   - 可以在客户端缓存资源，但每次使用必须去服务端对资源做`新鲜度校验`，根据校验结果`决定使用协商缓存【304】还是获取新资源【200】`
   - 等于使用资源前强制做新鲜度检验

6. no-store

   - 永远不缓存资源  永远都去服务器获取资源

#### Cache-Control字段 客户端参数

1. max-stale: 5 表示客户端到代理服务器上拿缓存的时候，即使`代理缓存过期了也不要紧`，只要过期时间在 5 秒之内，还是可以从代理中获取的。
2. min-fresh: 5 表示代理缓存`需要一定的新鲜度`，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。
3. only-if-cached 这个字段加上后表示客户端`只会接受代理缓存`，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 504（Gateway Timeout）。

#### 强制更新没过期的强缓存

1. ctrl+F5 
2. 更新资源名       webpack打包hash名

### 协商缓存

- 请求头 -- 响应头
- If-Modified-Since     Last-Modified
- If-None-Match          ETag              【优先级高】

#### Last-Modified

1. 绝对时间
2. 单位为秒
3. 只要文件变动，Last-Modified就会变动

#### ETag

1. 相对时间
2. 使用字符串做校验
3. 只要文件内容不变【`重复生成内容一样的文件`】，ETag就不变

### 缓存的配置-ngnix

- 非html缓存1个月
- html文件使用协商缓存

```
location / {

  # 其它配置
  ...

  if ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) {
    #非html缓存1个月
    add_header Cache-Control "public, max-age=2592000";
  }

  if ($request_filename ~* ^.*[.](html|htm)$) {
    #html文件使用协商缓存
    add_header Cache-Control "no-cache";
  }
}

作者：苏苏同学
链接：https://juejin.cn/post/7052527032491573279
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## TCP与UDP

### TCP-UDP区别

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP较少）；
3. 流模式与数据报模式；
4. TCP保证数据正确性，UDP可能丢包；
5. TCP保证数据顺序，UDP不保证;
6. UDP可进行高效传输，实时性更强。

### 三次握手四次挥手

#### 为什么三次不是两次

#### 为什么四次不是三次

#### TIME_WAIT为啥2MSL



### 保证可靠性

![image-20220602161551833](D:\Sync\typora图片\image-20220602161551833.png)

#### 重传机制



#### 滑动窗口



#### 流量控制



#### 拥塞控制

## HTTP 1.0

`短连接`:每次发送请求都要【重新建立TCP请求】,即三次握手,性能较差；

`无host头域`:也就是http请求头里的host；

`不允许断点续传`,而且不能只传输对象的一部分,要求传输整个对象。

`缓存策略`：Last-Modify【If-Modified-Since】

## HTTP 1.1

### 优化

1. `长连接`：默认开启【Connection : Keep-Alive】，在同一个TCP上传送多个HTTP请求和响应【**`串行`-排队-队头阻塞**】;
2. `Host头处理`:在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址,因此,请求消息中的URL并没有传递主机名(hostname)。但随着虚拟主机技术的发展,在一台物理服务器上可以存在多个虚拟主机(Multi-homed Web Servers) ,并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域,且请求消息中如果没有Host头域会报【400 Bad Request】；
3. `请求头引入range`：允许请求资源的某个部分，返回码【206 Partial Content】
4. `缓存策略`：ETag【If-None-Match】，优于Last-Modify
5. `管道化`：只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

### 存在的问题

1. 并发连接有限；【队头阻塞问题】
3. header太大且重复；
4. 并发后不能控制优先级；
5. 不能server端推送

### [HTTP1.1 队头阻塞](https://juejin.cn/post/7049296242924322830)

- 原因

  1. HTTP1.1 `keep-alive长连接`；
  2. `TCP复用`，一个TCP上多个HTTP连接；
  3. HTTP连接基于`请求-应答`模式，下一个需要上一个有应答才可以；
  4. 造成`队头阻塞`

- 解决方案   【治标不治本】

  1. `并发连接`：每个域名下能够`建立多个TCP通道`(chrome支持六个)

     `并发连接的【弊端】`：
     【并发连接和域名分片】并没有真正从 HTTP 本身的层面解决问题，只是【增加了 TCP 连接】，分摊风险而已。
     多条 TCP 连接会`竞争有限的带宽`，让真正`【优先级高】的请求不能优先处理`【若只有一条TCP长连接，因为没开启pipe，【按照请求顺序发送】，变相理解为有优先级】。

  2. `域名分片`：多级域名，建立更多的TCP通道

## HTTPS

### 与HTTP区别

1. HTTP只需进行TCP的三次握手即可，HTTPS还需要SSL/TLS握手产生【会话秘钥】；
2. HTTP是明文传输的，HTTPS使用【会话秘钥】对数据进行加密后传输；
3. HTTP `端⼝号` 80，HTTPS 端⼝号 443；
4. HTTPS需要向` CA（证书权威机构）申请数字证书`，来保证服务器未被中间人篡改【服务器的公钥保存在CA证书内】。

#### HTTP风险

HTTP 由于是`明⽂传输`，所以安全上存在以下三个⻛险：

1. **窃听风险**，⽐如通信链路上可以获取通信内容，⽤户号容易没。
2. **篡改风险**，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。
3. **冒充风险**，⽐如冒充淘宝⽹站，⽤户钱容易没。



HTTP**S** 在` HTTP 与 TCP 层之间`加⼊了 SSL/TLS 协议，可以很好的解决了上述的⻛险：

1. **信息加密**：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。
2. **校验机制**：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。
3. **身份证书**：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。

#### HTTPS的解决方案

1. **混合加密**：实现信息的**机密性**，解决了窃听的⻛险。
2. **摘要算法**：实现**完整性**，为数据⽣成独⼀⽆⼆的「指纹」，，⽤于校验数据的完整性，解决了`篡改`的⻛险。
3. **[数字证书](https://juejin.cn/post/6995549209348816909#heading-15)**：将服务器公钥放⼊到**数字证书**中，解决了冒充的⻛险。

### 混合加密

HTTPS 采⽤的是**对称加密**和**⾮对称加密**结合的「混合加密」⽅式：

1. 在通信建⽴前采⽤**⾮对称加密**的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
2. 在通信过程中全部使⽤**对称加密**的「会话秘钥」的⽅式加密明⽂数据。



采⽤「混合加密」的⽅式的原因：

1. **对称加密**只使⽤⼀个密钥，运算速度快，`密钥必须保密，⽆法做到安全的密钥交换`。
2. **非对称加密**使⽤两个密钥：公钥和私钥，`公钥可以任意分发⽽私钥保密`，解决了密钥交换问题但`速度慢`。

### 摘要算法

1. 使用摘要算法算出明文数据的【指纹】；
2. 将【明文+指纹】一同使用【会话秘钥】加密；
3. 服务器收到数据后使用【会话秘钥】解密为【明文+指纹】；
4. 服务器使用【摘要算法】再对接收到的数据算出【校验指纹】；
5. 对比【校验指纹】与【指纹】；
6. **`问题？?？？ 篡改内容时 把【指纹】也改了不得了？？`**
7. `因为收到的摘要也可能被篡改，所以需要使用更安全的手段：数字签名；`

![image-20220601171236311](D:\Sync\typora图片\image-20220601171236311.png)

### 数字证书

**数字证书保证公钥是可信的**

客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。

这就存在些问题，如何保证公钥不被篡改和信任度？

所以这⾥就需要借助`第三⽅权威机构 CA` （数字证书认证机构），将**`服务器公钥放在数字证书`**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![image-20220601170512365](D:\Sync\typora图片\image-20220601170512365.png)

### SSL/TLS协议

基本流程：

1. 客户端向服务器`索要并验证`服务器的公钥。
2. 双⽅`协商⽣产「会话秘钥」`。
3. 双⽅`采⽤「会话秘钥」`进⾏加密通信。



前两步也就是 SSL/TLS 的建⽴过程，也就是`握⼿阶段`  【`生成会话秘钥的过程`】。

### TLS1.2 四次握手

1. Client Hello
   - 浏览器发送【`第一随机数`、TLS版本、加密套件列表】
2. Server Hello
   - 服务器回应【`第二随机数`、数字证书、server_params、确定TLS版本、加密套件】
3. client 回应
   - 客户端`验证数字证书`；
   - 若验证通过，使用`数字证书内的公钥`对【报文】进行加密，传输给server；
   - **`报文内容包括`**【`第三个随机数`、之后使用(会话秘钥)通信、client结束握手通知】
4. server 回应
   - server收到【第三个随机数】后，通过协商的加密算法对【三个随机数】加密，获得【会话秘钥】；
   - 向client发送报文，告知【1. 之后使用(会话秘钥)通信；  2. server结束握手通知】

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd9b35c7a81b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



![image-20220407144040844](D:\Sync\typora图片\image-20220407144040844.png)

### TLS1.3 三次握手

#### 握手改进

流程如下:

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffda75857d404~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到`client_params`，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算`secret`，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。

这种 TLS 1.3 握手方式也被叫做**1-RTT握手**。但其实这种`1-RTT`的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。

### 中间人攻击



## HTTP 2.0

### 优化

1. 二进制传输
   - HTTP1.x是文本形式传输，`表现形式复杂【json，txt】`，二进制只有0、1，更加健壮；
2. 头部【header】压缩

3. 多路复用  【通过`二进制帧`】
4. 优先级设置
5. 服务端推送



### [二进制帧设计](https://juejin.cn/post/6844904100035821575#heading-97)

![image-20220602161702474](D:\Sync\typora图片\image-20220602161702474.png)

每个帧分为`帧头`和`帧体`【实际传输的数据】。

1. `帧长度`：三个字节
   - 表示`帧体`的长度。
2. `帧类型`：一个字节
   - 可分为**数据帧**和**控制帧**两种。数据帧用来存放 HTTP 报文，控制帧用来管理`流`的传输。
3. `帧标志`：一个字节
   - 共有 8 个标志位，常用的有 **END_HEADERS**表示头数据结束，**END_STREAM**表示单方向数据发送结束。
4. `流标识符`：四个字节
   - `Stream ID`, 也就是`流标识符`，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。

### [HTTP2  TCP层队头阻塞](https://zhuanlan.zhihu.com/p/330300133)

1. HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤；

2. 那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是 `HTTP/2 队头阻塞`问题。

## HTTP3.0

### 优化

![image-20220602150317799](D:\Sync\typora图片\image-20220602150317799.png)

HTTP/2 主要的问题在于，多个 HTTP 请求在`复⽤⼀个 TCP 连接`，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的`重传机制`，这样在⼀个 TCP 连接中的**所有的** **HTTP** **请求都必须等待这个丢了的包被重传回来**。【多路复用？？??】

HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了

HTTP/2 多个请求复⽤⼀个TCP连接，`⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求`。

这都是基于 TCP 传输层的问题，所以**HTTP3将HTTP下的TCP协议改成了UDP！**



UDP 是不可靠传输的，但基于 UDP 的 **QUIC** **协议** 可以实现类似 TCP 的可靠性传输。

QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，**其他流不会受到影响**。【`啥机制？？??`】

1. TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。
2. HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把
3. 以往的 TCP 和 TLS/1.3 的 6 次交互**合并成了** **3** **次，减少了交互次数**。

### 一些问题

QUIC 是新协议，对于很多⽹络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以

HTTP/3 现在普及的进度⾮常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

## 性能优化

前端性能优化主要可以从这个三个大点入手： 

### 一、更快的网络通信

#### 服务器通信层面

- CDN
  - 全局负载均衡
  - 缓存系统
- 减少请求次数
  - 资源合并

#### 数据传输层面

- 缓存：浏览器缓存
  - 强缓存
    - cache-contorl: max-age=30
    - expires: Wed, 21 Oct 2021 07:28:00 GMT
- 协商缓存
  - etag
  - last-modified
  - if-modified-since
  - if-none-match
- 压缩
  - 数据压缩：gzip
  - 代码文件压缩：HTML/CSS/JS 中的注释、空格、长变量等
  - 静态资源：字体图标，去除元数据，缩小尺寸以及分辨率
  - 头与报文
    - http1.1 中减少不必要的头
    - 减少 cookie 数据量

#### 代码层面

- webpack 打包层面
  - 样式抽离
  - js 压缩
  - 图片压缩
  - 使用 iconfont 矢量图
  - 引入 dll 动态链接库文件，前置打包不经常改动的资源包，例如：vue / vuex/ vue-router / ant-design 等
  - 多入口打包
- 技术层面
  - 前端路由懒加载
  - 数据懒加载
  - 虚拟列表

### 二、更高效的数据处理

- Http2
  - 头部压缩：专门的 HPACK 压缩算法
    - 索引表：客户端和服务器共同维护的一张表，表的内容分为 61 位的静态表（保存常用信息，例如：host/content-type）和动态表
    - 霍夫曼编码
- 链路复用
  - Http1 建立起 Tcp 连接，发送请求之后，服务器在处理请求的等待期间，这个期间又没有数据去发送，称为空挡期。链接断开是在服务器响应回溯之后
    - keep-alive 链接保持一段时间
    - HTTP2 可以利用空档期
    - 不需要再重复建立链接
- 二进制帧
  - Http1.1 文本字符分割的数据流，解析慢且容易出错
  - 二进制帧：帧长度、帧类型、帧标识

补充：采用 Http2 之后，可以减少资源合并的操作，因为首部压缩已经减少了**多请求**传输的数据量

### 三、框架的选择

- SSR 服务器端渲染
  - Nuxt.js
  - Next.js
- SPA 单页面应用
- SSG 静态站点生成方案

面试参考答案:

- web 类型应用的优化方法有很多，但是大体分两类
- 从**加载层面**，我们可以...
- 从**执行层面**，我们可以使用...

作者：我是970
链接：https://juejin.cn/post/6979172700254109709
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## HTTP无状态

## Placeholder