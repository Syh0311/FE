https://segmentfault.com/a/1190000005654451

## 总结

1. 微软提出的 冒泡 微软最后浮出水面变成了老大
2. 网景提出的 捕获 从父到子 最后沉到了水低
3. 折中后，事件默认为冒泡 【默认 false】 也算是给了网景面子【冒泡是 false】

## 事件冒泡与事件捕获

`事件冒泡`和`事件捕获`分别由`微软`和`网景`公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。
考虑下面这段代码，就不写 html->head,body 之类的代码了，自行脑补

```applescript
<div id="outer">
    <p id="inner">Click me!</p>
</div>
```

上面的代码当中一个 div 元素当中有一个 p 子元素，如果两个元素都有一个 click 的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？
为了解决这个问题微软和网景提出了两种几乎完全相反的概念。

## 事件冒泡 【泡泡越来越大】

微软提出了名为`事件冒泡(event bubbling)`的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从`最内层的元素开始发生，一直向上传播`，直到 document 对象。

因此在事件冒泡的概念下在 p 元素上发生 click 事件的顺序应该是**`p -> div -> body -> html -> document`**

## 事件捕获 【先捕获老大】

网景提出另一种事件流名为`事件捕获(event capturing)`。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

因此在事件捕获的概念下在 p 元素上发生 click 事件的顺序应该是**`document -> html -> body -> div -> p`**

## addEventListener 的第三个参数

网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准——**先捕获再冒泡**,即`先触发捕获事件,再触发冒泡事件`。
addEventListener 的第三个参数就是为冒泡和捕获准备的.
addEventListener 有三个参数：

> element.addEventListener(event, function, useCapture)

第一个参数是需要绑定的事件;

第二个参数是触发事件后要执行的函数;

第三个参数默认值是 false，表示在**事件冒泡阶段**调用事件处理函数;如果参数为 true，则表示在**事件捕获阶段**调用处理函数。
